"""
Factory Machine implementations for AI providers.
These classes handle the actual execution of AI generation requests.
"""
import os
import asyncio
import logging
from abc import ABC, abstractmethod
from datetime import datetime
from django.conf import settings
from django.core.files.base import ContentFile
from django.utils import timezone
from .models import Product, OrderItem, FactoryMachineInstance, LogEntry, FactoryMachineDefinition


logger = logging.getLogger(__name__)


class ExecutionResult:
    """Standardized result object for factory machine operations."""
    
    def __init__(self, success=False, product=None, error=None, metadata=None):
        self.success = success
        self.product = product
        self.error = error
        self.metadata = metadata or {}
        self.timestamp = timezone.now()


class BaseFactoryMachine(ABC):
    """
    Abstract base class for all factory machines.
    Defines the common interface and functionality.
    """
    
    def __init__(self, machine_definition):
        self.machine_definition = machine_definition
        self.provider = machine_definition.provider
        self.model_name = machine_definition.name
        
    @abstractmethod
    async def execute(self, order_item):
        """Execute the AI generation for an order item."""
        pass
    
    def log(self, level, message, order_item=None, extra_data=None):
        """Log events to the database."""
        try:
            LogEntry.objects.create(
                level=level,
                message=message,
                logger_name=f"{self.__class__.__name__}",
                module=self.__module__,
                order_item=order_item,
                extra_data=extra_data or {}
            )
        except Exception as e:
            # Fallback to regular logging if database fails
            logger.info(f"[{level}] {message} (DB log failed: {e})")
    
    def update_order_item_status(self, order_item, status, error_message=None):
        """Update order item status and timestamps."""
        try:
            order_item.status = status
            if status == 'processing' and not order_item.started_at:
                order_item.started_at = timezone.now()
            elif status in ['completed', 'failed']:
                order_item.completed_at = timezone.now()
            if error_message:
                order_item.error_message = error_message
            order_item.save()
        except Exception as e:
            logger.error(f"Failed to update order item status: {e}")
    
    def create_product(self, order_item, file_content, file_name, metadata):
        """Create a Product record from generated content."""
        # Create product first
        product = Product.objects.create(
            title=f"Generated by {self.machine_definition.display_name}",
            prompt=order_item.prompt,
            parameters=order_item.parameters,
            provider=self.provider,
            model_name=self.model_name,
            product_type='image',  # Default for now
            file_path='',  # Will be set after file save
            file_size=len(file_content),
            file_format=file_name.split('.')[-1] if '.' in file_name else 'jpg',
            width=metadata.get('width'),
            height=metadata.get('height'),
            seed=metadata.get('seed'),
            provider_id=metadata.get('provider_id', ''),
        )
        
        # Save the actual file and update file_path
        import os
        from django.conf import settings
        
        # Create media directory if it doesn't exist
        media_dir = os.path.join(settings.MEDIA_ROOT, 'generated', self.provider)
        os.makedirs(media_dir, exist_ok=True)
        
        # Save file
        file_path = f"generated/{self.provider}/{file_name}"
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        with open(full_path, 'wb') as f:
            f.write(file_content)
        
        # Update product with file path
        product.file_path = file_path
        product.save()
        
        return product


class FalFactoryMachine(BaseFactoryMachine):
    """Factory machine for fal.ai provider."""
    
    def __init__(self, machine_definition):
        super().__init__(machine_definition)
        # Configure fal client
        if settings.FAL_API_KEY:
            os.environ['FAL_KEY'] = settings.FAL_API_KEY
    
    async def execute(self, order_item):
        """Execute fal.ai generation."""
        try:
            import fal_client
            
            self.log('INFO', f'Starting generation for order item {order_item.id}', order_item)
            self.update_order_item_status(order_item, 'processing')
            
            # Prepare parameters
            arguments = {
                'prompt': order_item.prompt,
                **order_item.parameters
            }
            
            self.log('INFO', f'Submitting to {self.model_name} with args: {arguments}', order_item)
            
            # Submit to fal.ai (using sync version for now)
            import asyncio
            loop = asyncio.get_event_loop()
            
            # Run in executor to avoid blocking
            def submit_sync():
                handle = fal_client.submit(self.model_name, arguments=arguments)
                return handle.get()
            
            result = await loop.run_in_executor(None, submit_sync)
            
            self.log('INFO', f'Generation completed: {result}', order_item)
            
            # Process result
            if result and isinstance(result, dict) and 'images' in result and result['images']:
                image_info = result['images'][0]
                image_url = image_info['url']
                
                # Download the image
                import httpx
                async with httpx.AsyncClient() as client:
                    response = await client.get(image_url)
                    response.raise_for_status()
                    image_content = response.content
                
                # Create product
                metadata = {
                    'width': image_info.get('width'),
                    'height': image_info.get('height'),
                    'seed': result.get('seed'),
                    'provider_id': str(result.get('request_id', ''))
                }
                
                file_name = f"fal_{order_item.id}_{timezone.now().strftime('%Y%m%d_%H%M%S')}.jpg"
                product = self.create_product(order_item, image_content, file_name, metadata)
                
                # Update order item
                order_item.product = product
                self.update_order_item_status(order_item, 'completed')
                
                self.log('INFO', f'Product created: {product.id}', order_item)
                
                return ExecutionResult(
                    success=True,
                    product=product,
                    metadata=metadata
                )
            else:
                error_msg = "No images returned from fal.ai"
                self.log('ERROR', error_msg, order_item)
                self.update_order_item_status(order_item, 'failed', error_msg)
                return ExecutionResult(success=False, error=error_msg)
                
        except Exception as e:
            error_msg = f"fal.ai execution failed: {str(e)}"
            self.log('ERROR', error_msg, order_item, {'exception': str(e)})
            self.update_order_item_status(order_item, 'failed', error_msg)
            return ExecutionResult(success=False, error=error_msg)


class ReplicateFactoryMachine(BaseFactoryMachine):
    """Factory machine for Replicate provider."""
    
    def __init__(self, machine_definition):
        super().__init__(machine_definition)
        # Configure replicate client
        if settings.REPLICATE_API_TOKEN:
            os.environ['REPLICATE_API_TOKEN'] = settings.REPLICATE_API_TOKEN
    
    async def execute(self, order_item):
        """Execute Replicate generation."""
        try:
            import replicate
            
            self.log('INFO', f'Starting generation for order item {order_item.id}', order_item)
            self.update_order_item_status(order_item, 'processing')
            
            # Prepare input parameters
            input_params = {
                'prompt': order_item.prompt,
                **order_item.parameters
            }
            
            self.log('INFO', f'Submitting to {self.model_name} with input: {input_params}', order_item)
            
            # Submit to Replicate (using async)
            output = await replicate.async_run(
                self.model_name,
                input=input_params
            )
            
            self.log('INFO', f'Generation completed: {type(output)}', order_item)
            
            # Process result - Replicate returns FileOutput objects or URLs
            if output:
                if hasattr(output, '__iter__') and not isinstance(output, str):
                    # Multiple outputs, take the first
                    output = list(output)[0] if output else None
                
                if output:
                    # Download the file
                    if hasattr(output, 'read'):
                        # FileOutput object
                        image_content = output.read()
                    else:
                        # URL string
                        import httpx
                        async with httpx.AsyncClient() as client:
                            response = await client.get(str(output))
                            response.raise_for_status()
                            image_content = response.content
                    
                    # Create product
                    metadata = {
                        'width': input_params.get('width', 1024),
                        'height': input_params.get('height', 1024),
                        'seed': input_params.get('seed'),
                        'provider_id': f"replicate_{timezone.now().timestamp()}"
                    }
                    
                    file_name = f"replicate_{order_item.id}_{timezone.now().strftime('%Y%m%d_%H%M%S')}.jpg"
                    product = self.create_product(order_item, image_content, file_name, metadata)
                    
                    # Update order item
                    order_item.product = product
                    self.update_order_item_status(order_item, 'completed')
                    
                    self.log('INFO', f'Product created: {product.id}', order_item)
                    
                    return ExecutionResult(
                        success=True,
                        product=product,
                        metadata=metadata
                    )
            
            error_msg = "No output returned from Replicate"
            self.log('ERROR', error_msg, order_item)
            self.update_order_item_status(order_item, 'failed', error_msg)
            return ExecutionResult(success=False, error=error_msg)
                
        except Exception as e:
            error_msg = f"Replicate execution failed: {str(e)}"
            self.log('ERROR', error_msg, order_item, {'exception': str(e)})
            self.update_order_item_status(order_item, 'failed', error_msg)
            return ExecutionResult(success=False, error=error_msg)


def get_factory_machine(machine_definition):
    """Factory function to get the appropriate machine implementation."""
    if machine_definition.provider == 'fal.ai':
        return FalFactoryMachine(machine_definition)
    elif machine_definition.provider == 'replicate':
        return ReplicateFactoryMachine(machine_definition)
    else:
        raise ValueError(f"Unknown provider: {machine_definition.provider}")


def execute_order_item_sync(order_item_id):
    """Execute a single order item synchronously."""
    try:
        order_item = OrderItem.objects.get(id=order_item_id)
        machine_definition = FactoryMachineDefinition.objects.get(
            name=order_item.order.factory_machine_name
        )
        
        factory_machine = get_factory_machine(machine_definition)
        
        # Run the async execution in a new event loop
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(factory_machine.execute(order_item))
        finally:
            loop.close()
        
        return result
        
    except Exception as e:
        logger.error(f"Failed to execute order item {order_item_id}: {e}")
        return ExecutionResult(success=False, error=str(e))


def process_pending_orders_sync():
    """Process all pending order items synchronously."""
    pending_items = OrderItem.objects.filter(status='pending')
    
    if not pending_items:
        logger.info("No pending order items to process")
        return
    
    logger.info(f"Processing {pending_items.count()} pending order items")
    
    for item in pending_items:
        try:
            result = execute_order_item_sync(item.id)
            if result.success:
                logger.info(f"Successfully processed order item {item.id}")
            else:
                logger.error(f"Failed to process order item {item.id}: {result.error}")
        except Exception as e:
            logger.error(f"Exception processing order item {item.id}: {e}")


# Keep async versions for when called from async context
async def execute_order_item(order_item_id):
    """Execute a single order item."""
    from django.db import sync_to_async
    
    try:
        order_item = await sync_to_async(OrderItem.objects.get)(id=order_item_id)
        machine_definition = await sync_to_async(FactoryMachineDefinition.objects.get)(
            name=order_item.order.factory_machine_name
        )
        
        factory_machine = get_factory_machine(machine_definition)
        result = await factory_machine.execute(order_item)
        
        return result
        
    except Exception as e:
        logger.error(f"Failed to execute order item {order_item_id}: {e}")
        return ExecutionResult(success=False, error=str(e))


async def process_pending_orders():
    """Process all pending order items."""
    from django.db import sync_to_async
    
    pending_items = await sync_to_async(list)(OrderItem.objects.filter(status='pending'))
    
    if not pending_items:
        logger.info("No pending order items to process")
        return
    
    logger.info(f"Processing {len(pending_items)} pending order items")
    
    for item in pending_items:
        try:
            result = await execute_order_item(item.id)
            if result.success:
                logger.info(f"Successfully processed order item {item.id}")
            else:
                logger.error(f"Failed to process order item {item.id}: {result.error}")
        except Exception as e:
            logger.error(f"Exception processing order item {item.id}: {e}")